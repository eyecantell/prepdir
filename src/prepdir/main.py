import argparse
import logging
import os
import sys
from typing import Optional, List, Dict, Union, Tuple
from .prepdir_processor import PrepdirProcessor
from .prepdir_file_entry import PrepdirFileEntry
from .prepdir_output_file import PrepdirOutputFile
from .core import __version__

logger = logging.getLogger(__name__)

def configure_logging(verbose: bool = False, loglevel: Optional[str] = None) -> None:
    """Configure logging based on environment variable or verbose flag."""
    loglevel = loglevel or (os.environ.get("LOGLEVEL", "INFO") if not verbose else "DEBUG")
    logging.basicConfig(
        level=loglevel.upper(),
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )
    logger.debug("Set logging level to %s", loglevel)

def run(
    directory: str = ".",
    extensions: Optional[List[str]] = None,
    specific_files: Optional[List[str]] = None,
    output_file: Optional[str] = None,
    config_path: Optional[str] = None,
    scrub_uuids: Optional[bool] = None,
    scrub_hyphenless_uuids: Optional[bool] = None,
    replacement_uuid: Optional[str] = None,
    use_unique_placeholders: bool = False,
    include_all: bool = False,
    include_prepdir_files: bool = False,
    verbose: bool = False,
    return_raw: bool = False,
) -> Union[PrepdirOutputFile, Tuple[str, Dict[str, str], List[PrepdirFileEntry], Dict]]:
    """
    Run prepdir to generate a formatted string of file contents.

    Args:
        directory: Starting directory path.
        extensions: List of file extensions to include (without the dot).
        specific_files: List of specific file paths to process.
        output_file: Path to save the output file.
        config_path: Path to custom config file.
        scrub_uuids: If True, scrub UUIDs in file contents.
        scrub_hyphenless_uuids: If True, scrub hyphen-less UUIDs.
        replacement_uuid: UUID to replace detected UUIDs with when use_unique_placeholders is False.
        use_unique_placeholders: If True, replace UUIDs with unique placeholders.
        include_all: If True, ignore exclusion lists.
        include_prepdir_files: If True, include files previously generated by prepdir.
        verbose: If True, print additional information.
        return_raw: If True, return raw tuple instead of PrepdirOutputFile.

    Returns:
        PrepdirOutputFile or tuple of (content, UUID mapping, list of PrepdirFileEntry objects, metadata).
    """
    configure_logging(verbose=verbose)
    logger.debug("Running prepdir on directory: %s", directory)
    
    processor = PrepdirProcessor(
        directory=directory,
        extensions=extensions,
        specific_files=specific_files,
        output_file=output_file,
        config_path=config_path,
        scrub_uuids=scrub_uuids,
        scrub_hyphenless_uuids=scrub_hyphenless_uuids,
        replacement_uuid=replacement_uuid,
        use_unique_placeholders=use_unique_placeholders,
        include_all=include_all,
        include_prepdir_files=include_prepdir_files,
        verbose=verbose,
    )
    
    output = processor.generate_output()
    processor.save_output(output, output_file)
    
    if return_raw:
        return (
            output.content,
            {k: v for f in output.files for k, v in f.uuid_mapping.items()},
            output.files,
            output.metadata,
        )
    return output

def main():
    """Command-line interface for prepdir."""
    parser = argparse.ArgumentParser(
        description="Directory traversal utility to prepare project contents for review."
    )
    parser.add_argument(
        "directory",
        nargs="?",
        default=".",
        help="Directory to process (default: current directory)",
    )
    parser.add_argument(
        "-e",
        "--extensions",
        nargs="*",
        help="File extensions to include (e.g., py txt)",
    )
    parser.add_argument(
        "-f",
        "--files",
        nargs="*",
        help="Specific files to process (relative or absolute paths)",
    )
    parser.add_argument(
        "-o",
        "--output",
        help="Output file name (default: prepped_dir.txt)",
        default="prepped_dir.txt",
    )
    parser.add_argument(
        "--init",
        action="store_true",
        help="Initialize a local config.yaml",
    )
    parser.add_argument(
        "--config",
        help="Path to a custom config file",
    )
    parser.add_argument(
        "--no-scrub-uuids",
        action="store_true",
        help="Disable UUID scrubbing",
    )
    parser.add_argument(
        "--no-scrub-hyphenless-uuids",
        action="store_true",
        help="Disable hyphen-less UUID scrubbing",
    )
    parser.add_argument(
        "--replacement-uuid",
        help="Custom UUID to replace detected UUIDs",
    )
    parser.add_argument(
        "--use-unique-placeholders",
        action="store_true",
        help="Replace UUIDs with unique placeholders (e.g., PREPDIR_UUID_PLACEHOLDER_n)",
    )
    parser.add_argument(
        "--all",
        action="store_true",
        help="Include all files, ignoring exclusions",
    )
    parser.add_argument(
        "--include-prepdir-files",
        action="store_true",
        help="Include prepdir-generated files",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Enable verbose output",
    )
    parser.add_argument(
        "--version",
        action="version",
        help="Show version and exit",
        version=f"prepdir {__version__}",
    )
    
    args = parser.parse_args()
    
    if args.init:
        PrepdirProcessor.init_config(config_path=args.config, force=False)
        return
    
    configure_logging(verbose=args.verbose)
    
    scrub_uuids = not args.no_scrub_uuids
    scrub_hyphenless = not args.no_scrub_hyphenless_uuids
    
    try:
        output = run(
            directory=args.directory,
            extensions=args.extensions,
            specific_files=args.files,
            output_file=args.output,
            config_path=args.config,
            scrub_uuids=scrub_uuids,
            scrub_hyphenless_uuids=scrub_hyphenless,
            replacement_uuid=args.replacement_uuid,
            use_unique_placeholders=args.use_unique_placeholders,
            include_all=args.all,
            include_prepdir_files=args.include_prepdir_files,
            verbose=args.verbose,
            return_raw=False,
        )
        if not args.output:
            print(output.content)
    except ValueError as e:
        logger.error("Error: %s", str(e))
        sys.exit(1)
    except Exception as e:
        logger.error("Unexpected error: %s", str(e))
        sys.exit(1)

if __name__ == "__main__":
    main()