#!/usr/bin/env python3
"""
prepdir - Utility to traverse directories and prepare file contents for review

This tool walks through directories printing relative paths and file contents,
making it easy to share code and project structures with AI assistants for
review, analysis, and improvement suggestions.
"""
import os
import argparse
import sys
import yaml
import fnmatch
import re
import uuid
from datetime import datetime
from contextlib import redirect_stdout
from pathlib import Path
from importlib.metadata import version
from prepdir.config import load_config
import logging
from io import StringIO

logger = logging.getLogger(__name__)

# UUID regex pattern (8-4-4-4-12 hexadecimal characters, case-insensitive, with word boundaries)
UUID_PATTERN = re.compile(
    r'\b[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\b',
    re.IGNORECASE
)

# File delimiter and header/footer patterns
DELIMITER = "=-=-=-=-=-=-=-="
HEADER_PATTERN = re.compile(rf"^{DELIMITER} Begin File: '(.*?)' {DELIMITER}$")
FOOTER_PATTERN = re.compile(rf"^{DELIMITER} End File: '(.*?)' {DELIMITER}$")
GENERATED_HEADER_PATTERN = re.compile(r"^File listing generated \d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d+ by prepdir \(pip install prepdir\)$")

def is_valid_uuid(value: str) -> bool:
    """Check if a string is a valid UUID."""
    try:
        uuid.UUID(value)
        return True
    except ValueError:
        return False

def scrub_uuids(content: str, replacement_uuid: str) -> tuple[str, bool]:
    """Replace UUIDs in content with the specified replacement UUID, return content and whether any were replaced."""
    original_content = content
    content = UUID_PATTERN.sub(replacement_uuid, content)
    return content, content != original_content

def is_prepdir_generated(file_path: str) -> bool:
    """Check if a file was generated by prepdir based on its header."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            first_line = f.readline().strip()
            return first_line.startswith("File listing generated") and "by prepdir" in first_line
    except (UnicodeDecodeError, IOError):
        return False

def init_config(config_path=".prepdir/config.yaml", force=False):
    """Initialize a local config.yaml with the package's default config."""
    config_path = Path(config_path)
    config_dir = config_path.parent
    config_dir.mkdir(parents=True, exist_ok=True)
    
    if config_path.exists() and not force:
        print(f"Error: '{config_path}' already exists. Use --force to overwrite.", file=sys.stderr)
        sys.exit(1)
    
    try:
        config = load_config("prepdir")
        with config_path.open('w', encoding='utf-8') as f:
            yaml.safe_dump(config.as_dict(), f)
        print(f"Created '{config_path}' with default configuration.")
    except Exception as e:
        print(f"Error: Failed to create '{config_path}': {str(e)}", file=sys.stderr)
        sys.exit(1)

def is_excluded_dir(dirname, root, directory, excluded_dirs):
    """Check if directory should be excluded from traversal using glob patterns."""
    relative_path = os.path.relpath(os.path.join(root, dirname), directory)
    for pattern in excluded_dirs:
        pattern = pattern.rstrip('/')
        if fnmatch.fnmatch(dirname, pattern) or fnmatch.fnmatch(relative_path, pattern):
            return True
    return False

def is_excluded_file(filename, root, directory, excluded_files, output_file, include_prepdir_files):
    """Check if file should be excluded from traversal using glob patterns, if it's the output file, or if it's prepdir-generated."""
    full_path = os.path.abspath(os.path.join(root, filename))
    if output_file and full_path == os.path.abspath(output_file):
        return True
    
    if not include_prepdir_files and is_prepdir_generated(full_path):
        return True
    
    relative_path = os.path.relpath(full_path, directory)
    for pattern in excluded_files:
        if fnmatch.fnmatch(filename, pattern) or fnmatch.fnmatch(relative_path, pattern):
            return True
    return False

def display_file_content(file_full_path: str, directory: str, scrub_uuids_enabled: bool, replacement_uuid: str) -> bool:
    """Display the content of a file with appropriate header, optionally scrubbing UUIDs, return if UUIDs were scrubbed."""
    dashes = '=-' * 7 + "="
    relative_path = os.path.relpath(file_full_path, directory)
    
    print(f"{dashes} Begin File: '{relative_path}' {dashes}")
    
    uuids_scrubbed = False
    try:
        with open(file_full_path, 'r', encoding='utf-8') as f:
            content = f.read()
            if scrub_uuids_enabled:
                content, uuids_scrubbed = scrub_uuids(content, replacement_uuid)
            print(content)
    except UnicodeDecodeError:
        print("[Binary file or encoding not supported]")
    except Exception as e:
        print(f"[Error reading file: {str(e)}]")
    
    print(f"{dashes} End File: '{relative_path}' {dashes}")
    return uuids_scrubbed

def traverse_directory(directory, extensions=None, excluded_dirs=None, excluded_files=None, include_all=False, verbose=False, output_file=None, include_prepdir_files=False, scrub_uuids_enabled=True, replacement_uuid="00000000-0000-0000-0000-000000000000"):
    """
    Traverse the directory and display file contents.
    
    Args:
        directory (str): Starting directory path
        extensions (list): List of file extensions to include (without the dot)
        excluded_dirs (list): Directory glob patterns to exclude
        excluded_files (list): File glob patterns to exclude
        include_all (bool): If True, ignore exclusion lists
        verbose (bool): If True, print additional information about skipped files
        output_file (str): Path to the output file to exclude from traversal
        include_prepdir_files (bool): If True, include files previously generated by prepdir
        scrub_uuids_enabled (bool): If True, scrub UUIDs in file contents
        replacement_uuid (str): UUID to replace detected UUIDs with
    """
    directory = os.path.abspath(directory)
    files_found = False
    any_uuids_scrubbed = False
    
    print(f"File listing generated {datetime.now()} by prepdir version {version('prepdir')} (pip install prepdir)")
    print(f"Base directory is '{Path.cwd()}'")
    if scrub_uuids_enabled:
        print(f"Note: Valid UUIDs in file contents will be scrubbed and replaced with '{replacement_uuid}'.")
    
    for root, dirs, files in os.walk(directory):
        if not include_all:
            skipped_dirs = [d for d in dirs if is_excluded_dir(d, root, directory, excluded_dirs)]
            if verbose:
                for d in skipped_dirs:
                    print(f"Skipping directory: {os.path.join(root, d)} (excluded in config)", file=sys.stderr)
            dirs[:] = [d for d in dirs if not is_excluded_dir(d, root, directory, excluded_dirs)]
        
        for file in files:
            full_path = os.path.abspath(os.path.join(root, file))
            if is_excluded_file(file, root, directory, excluded_files, output_file, include_prepdir_files):
                if verbose:
                    reason = (
                        "output file" if output_file and full_path == os.path.abspath(output_file)
                        else "prepdir-generated file" if is_prepdir_generated(full_path) and not include_prepdir_files
                        else "excluded in config"
                    )
                    print(f"Skipping file: {os.path.join(root, file)} ({reason})", file=sys.stderr)
                continue
            
            if extensions:
                file_ext = os.path.splitext(file)[1].lstrip('.')
                if file_ext not in extensions:
                    if verbose:
                        print(f"Skipping file: {os.path.join(root, file)} (extension not in {extensions})", file=sys.stderr)
                    continue
            
            files_found = True
            full_path = os.path.join(root, file)
            if display_file_content(full_path, directory, scrub_uuids_enabled, replacement_uuid):
                any_uuids_scrubbed = True
    
    if not files_found:
        if extensions:
            print(f"No files with extension(s) {', '.join(extensions)} found.")
        else:
            print("No files found.")

def validate_output_file(file_path: str) -> dict:
    """
    Validate a prepdir-generated output file to ensure it has correct structure.

    Args:
        file_path (str): Path to the output file to validate.

    Returns:
        dict: Validation result with keys:
            - is_valid (bool): True if the file is valid, False otherwise.
            - errors (list): List of error messages for invalid structure.
            - warnings (list): List of warning messages for minor issues.

    Raises:
        FileNotFoundError: If the file does not exist.
        UnicodeDecodeError: If the file cannot be read as text.
    """
    errors = []
    warnings = []
    open_headers = []
    line_number = 0
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        if not lines:
            errors.append("File is empty.")
            return {"is_valid": False, "errors": errors, "warnings": warnings}

        # Check the generated header (first line)
        first_line = lines[0].strip()
        if not GENERATED_HEADER_PATTERN.match(first_line.replace(f" version {version('prepdir')}", "")):
            errors.append(f"Line 1: Missing or invalid prepdir header. Got: '{first_line}'")
        else:
            # Check the second line (Base directory)
            if len(lines) < 2 or not lines[1].strip().startswith("Base directory is"):
                warnings.append("Line 2: Missing or invalid base directory line.")

        for line_number, line in enumerate(lines, 1):
            line = line.strip()

            # Skip empty lines or content lines
            if not line or (not HEADER_PATTERN.match(line) and not FOOTER_PATTERN.match(line)):
                continue

            # Check for header
            header_match = HEADER_PATTERN.match(line)
            if header_match:
                file_path = header_match.group(1)
                open_headers.append((file_path, line_number))
                continue

            # Check for footer
            footer_match = FOOTER_PATTERN.match(line)
            if footer_match:
                file_path = footer_match.group(1)
                if not open_headers:
                    errors.append(f"Line {line_number}: Footer for '{file_path}' without matching header.")
                else:
                    last_header_path, header_line = open_headers[-1]
                    if last_header_path != file_path:
                        errors.append(
                            f"Line {line_number}: Footer for '{file_path}' does not match open header "
                            f"'{last_header_path}' from line {header_line}."
                        )
                    else:
                        open_headers.pop()
                continue

            # If line matches neither header nor footer but looks like a delimiter
            if DELIMITER in line:
                warnings.append(f"Line {line_number}: Malformed header or footer: '{line}'")

        # Check for unclosed headers
        for file_path, header_line in open_headers:
            errors.append(f"Line {header_line}: Header for '{file_path}' has no matching footer.")

        is_valid = len(errors) == 0
        return {"is_valid": is_valid, "errors": errors, "warnings": warnings}

    except FileNotFoundError:
        raise FileNotFoundError(f"File '{file_path}' does not exist.")
    except UnicodeDecodeError:
        raise UnicodeDecodeError(f"File '{file_path}' cannot be read as text.", b"", 0, 0, "Invalid encoding")

def run(
    directory: str = ".",
    extensions: list = None,
    output_file: str = None,
    include_all: bool = False,
    config_path: str = None,
    verbose: bool = False,
    include_prepdir_files: bool = False,
    scrub_uuids: bool = True,
    replacement_uuid: str = "00000000-0000-0000-0000-000000000000"
) -> str:
    """
    Programmatically run prepdir to traverse a directory and prepare file contents.

    Args:
        directory (str): Directory to traverse (default: current directory).
        extensions (list): List of file extensions to include (without dot, e.g., ["py", "txt"]).
        output_file (str): Path to save output (if None, returns content as string).
        include_all (bool): If True, ignore exclusion lists in config.
        config_path (str): Path to custom configuration YAML file.
        verbose (bool): If True, log additional information about skipped files.
        include_prepdir_files (bool): If True, include prepdir-generated files.
        scrub_uuids (bool): If True, scrub UUIDs in file contents.
        replacement_uuid (str): UUID to replace detected UUIDs with.

    Returns:
        str: Formatted content of traversed files.

    Raises:
        ValueError: If directory does not exist or is not a directory, or if replacement_uuid is invalid.
    """
    # Configure logging
    logging.basicConfig(level=logging.DEBUG if verbose else logging.INFO, format='%(levelname)s: %(message)s')

    # Validate directory
    if not os.path.exists(directory):
        raise ValueError(f"Directory '{directory}' does not exist.")
    if not os.path.isdir(directory):
        raise ValueError(f"'{directory}' is not a directory.")

    # Load configuration
    config = load_config("prepdir", config_path)
    excluded_dirs = [] if include_all else config.get('exclude.directories', [])
    excluded_files = [] if include_all else config.get('exclude.files', [])

    # Validate replacement UUID
    if not is_valid_uuid(replacement_uuid):
        logger.error(f"Invalid replacement UUID: '{replacement_uuid}'. Using default nil UUID.")
        replacement_uuid = "00000000-0000-0000-0000-000000000000"

    # Capture output
    output = StringIO()
    with redirect_stdout(output):
        traverse_directory(
            directory,
            extensions,
            excluded_dirs,
            excluded_files,
            include_all,
            verbose,
            output_file=output_file,
            include_prepdir_files=include_prepdir_files,
            scrub_uuids_enabled=scrub_uuids,
            replacement_uuid=replacement_uuid
        )
    
    content = output.getvalue()

    # Write to output file if specified
    if output_file:
        output_path = Path(output_file)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with output_path.open('w', encoding='utf-8') as f:
            f.write(content)

    return content

def main():
    parser = argparse.ArgumentParser(
        prog='prepdir',
        description='Traverse directory and prepare file contents for review.'
    )
    parser.add_argument(
        'directory', 
        nargs='?', 
        default='.', 
        help='Directory to traverse (default: current directory)'
    )
    parser.add_argument(
        '-e', '--extensions', 
        nargs='+', 
        help='Filter files by extension(s) (without dot, e.g., "py txt")'
    )
    parser.add_argument(
        '-o', '--output',
        default='prepped_dir.txt',
        help='Output file for results (default: prepped_dir.txt)'
    )
    parser.add_argument(
        '--all',
        action='store_true',
        help='Include all files and directories, ignoring exclusions in config.yaml'
    )
    parser.add_argument(
        '--config',
        help='Path to configuration YAML file'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Print verbose output about skipped files and directories'
    )
    parser.add_argument(
        '--init',
        action='store_true',
        help='Initialize a local .prepdir/config.yaml with default configuration'
    )
    parser.add_argument(
        '--force',
        action='store_true',
        help='Force overwrite of existing config file when using --init'
    )
    parser.add_argument(
        '--include-prepdir-files',
        action='store_true',
        help='Include files previously generated by prepdir (excluded by default)'
    )
    parser.add_argument(
        '--no-scrub-uuids',
        action='store_true',
        help='Disable scrubbing of UUIDs in file contents (default: enabled)'
    )
    parser.add_argument(
        '--replacement-uuid',
        help='Custom UUID to replace detected UUIDs (default: 00000000-0000-0000-0000-000000000000)'
    )
    parser.add_argument(
        '--version',
        action='version',
        version=f'%(prog)s {version("prepdir")}',
        help='Show the version number and exit'
    )
    
    args = parser.parse_args()
    
    # Handle --init
    if args.init:
        init_config(args.config or ".prepdir/config.yaml", args.force)
        sys.exit(0)
    
    # Run prepdir programmatically
    try:
        run(
            directory=args.directory,
            extensions=args.extensions,
            output_file=args.output,
            include_all=args.all,
            config_path=args.config,
            verbose=args.verbose,
            include_prepdir_files=args.include_prepdir_files,
            scrub_uuids=not args.no_scrub_uuids,
            replacement_uuid=args.replacement_uuid or "00000000-0000-0000-0000-000000000000"
        )
    except ValueError as e:
        print(f"Error: {str(e)}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()