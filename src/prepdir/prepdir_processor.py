from pathlib import Path
from typing import List, Optional, Iterator, Dict
import os
import logging
import sys
import fnmatch
import re
from datetime import datetime
from io import StringIO
from contextlib import redirect_stdout
from dynaconf import Dynaconf
from prepdir.config import load_config, __version__, init_config
from prepdir.prepdir_file_entry import PrepdirFileEntry
from prepdir.prepdir_output_file import PrepdirOutputFile
from prepdir.scrub_uuids import HYPHENATED_UUID_PATTERN
from prepdir.is_excluded_file import is_excluded_dir, is_excluded_file

logger = logging.getLogger(__name__)

class PrepdirProcessor:
    """Manages generation and parsing of prepdir output files."""
    
    def __init__(
        self,
        directory: str,
        extensions: Optional[List[str]] = None,
        specific_files: Optional[List[str]] = None,
        output_file: Optional[str] = None,
        config_path: Optional[str] = None,
        scrub_hyphenated_uuids: Optional[bool] = None,
        scrub_hyphenless_uuids: Optional[bool] = None,
        replacement_uuid: Optional[str] = None,
        use_unique_placeholders: bool = False,
        ignore_exclusions: bool = False,
        include_prepdir_files: bool = False,
        quiet: bool = False,
        verbose: int = 0,
        stdout=sys.stdout,
        stderr=sys.stderr,
    ):
        """
        Initialize the PrepdirProcessor with configuration options.

        Args:
            directory: Starting directory path.
            extensions: List of file extensions to include (without the dot).
            specific_files: List of specific file paths to process.
            output_file: Path to save the output file.
            config_path: Path to custom config file.
            scrub_hyphenated_uuids: If True, scrub hyphenated UUIDs in file contents.
            scrub_hyphenless_uuids: If True, scrub hyphen-less UUIDs.
            replacement_uuid: UUID to replace detected UUIDs with when use_unique_placeholders is False.
            use_unique_placeholders: If True, replace UUIDs with unique placeholders.
            ignore_exclusions: If True, ignore exclusion lists.
            include_prepdir_files: If True, include files previously generated by prepdir.
            quiet: If True, suppress user-facing output to stdout.
            verbose: Verbosity level (0: no diagnostics, 1: INFO, 2: DEBUG).
            stdout: Stream for user-facing output.
            stderr: Stream for error messages.

        Raises:
            ValueError: If directory is invalid or replacement_uuid is malformed.
        """
        self.directory = os.path.abspath(directory)
        if not os.path.exists(self.directory):
            raise ValueError(f"Directory '{self.directory}' does not exist")
        if not os.path.isdir(self.directory):
            raise ValueError(f"'{self.directory}' is not a directory")

        self.config = self._load_config(config_path, verbose, quiet, stdout, stderr)
        self.extensions = extensions or self.config.get("DEFAULT_EXTENSIONS", [])
        self.specific_files = specific_files or []
        self.output_file = output_file or self.config.get("DEFAULT_OUTPUT_FILE", "prepped_dir.txt")
        self.ignore_exclusions = ignore_exclusions or self.config.get("IGNORE_EXCLUSIONS", False)
        self.include_prepdir_files = include_prepdir_files or self.config.get("INCLUDE_PREPDIR_FILES", False)
        self.verbose = verbose
        self.quiet = quiet
        self.stdout = stdout
        self.stderr = stderr

        self.scrub_hyphenated_uuids = (
            scrub_hyphenated_uuids
            if scrub_hyphenated_uuids is not None
            else self.config.get("SCRUB_HYPHENATED_UUIDS", True)
        )
        self.scrub_hyphenless_uuids = (
            scrub_hyphenless_uuids
            if scrub_hyphenless_uuids is not None
            else self.config.get("SCRUB_HYPHENLESS_UUIDS", True)
        )
        if replacement_uuid is not None and not re.fullmatch(HYPHENATED_UUID_PATTERN, replacement_uuid):
            logger.error(f"Invalid replacement UUID: '{replacement_uuid}'. Using config default.")
            print(f"Error: Invalid replacement UUID: '{replacement_uuid}'. Using config default.", file=stderr)
            replacement_uuid = None
        self.replacement_uuid = (
            replacement_uuid
            if replacement_uuid is not None
            else self.config.get("REPLACEMENT_UUID", "00000000-0000-0000-0000-000000000000")
        )
        self.use_unique_placeholders = use_unique_placeholders or self.config.get("USE_UNIQUE_PLACEHOLDERS", False)

        if self.verbose >= 2:
            logger.setLevel(logging.DEBUG)
        elif self.verbose >= 1:
            logger.setLevel(logging.INFO)

        if not quiet:
            print(f"Generated {datetime.now().isoformat()}", file=stdout)
            print(f"Traversing directory: {self.directory}", file=stdout)
            print(f"Extensions filter: {self.extensions if self.extensions else 'None'}", file=stdout)
            print(f"Output file: {self.output_file}", file=stdout)
            print(f"Ignoring exclusions: {self.ignore_exclusions}", file=stdout)
            print(f"Verbose mode: {self.verbose >= 1}", file=stdout)
        
        if (self.scrub_hyphenated_uuids or self.scrub_hyphenless_uuids) and not isinstance(
            self.replacement_uuid, str
        ):
            raise ValueError(
                f"Replacement UUID must be a string (got {self.replacement_uuid}) in order to scrub uuids"
            )

        if self.scrub_hyphenated_uuids and not quiet:
            if self.use_unique_placeholders:
                print(
                    "Note: Valid (hyphenated) UUIDs in file contents will be scrubbed and replaced with unique placeholders (e.g., PREPDIR_UUID_PLACEHOLDER_n).",
                    file=stdout,
                )
            else:
                print(
                    f"Note: Valid (hyphenated) UUIDs in file contents will be scrubbed and replaced with '{self.replacement_uuid}'.",
                    file=stdout,
                )
        if self.scrub_hyphenless_uuids and not quiet:
            if self.use_unique_placeholders:
                print(
                    "Note: Valid hyphen-less UUIDs in file contents will be scrubbed and replaced with unique placeholders (e.g., PREPDIR_UUID_PLACEHOLDER_n).",
                    file=stdout,
                )
            else:
                print(
                    f"Note: Valid hyphen-less UUIDs in file contents will be scrubbed and replaced with '{self.replacement_uuid.replace('-', '')}'.",
                    file=stdout,
                )

    def _load_config(self, config_path: Optional[str], verbose: int, quiet: bool, stdout, stderr) -> Dynaconf:
        """
        Load configuration using Dynaconf.

        Args:
            config_path: Path to custom config file.
            verbose: Verbosity level (0: no diagnostics, 1: INFO, 2: DEBUG).
            quiet: If True, suppress user-facing output to stdout.
            stdout: Stream for user-facing output.
            stderr: Stream for error messages.

        Returns:
            Dynaconf: Configured Dynaconf instance.
        """
        return load_config("prepdir", config_path, verbose, quiet, stdout, stderr)

    def is_excluded_output_file(self, filename: str, root: str) -> bool:
        """
        Check if a file is an excluded prepdir output file.

        Args:
            filename: Name of the file to check.
            root: Directory containing the file.

        Returns:
            bool: True if the file is an excluded output file, False otherwise.
        """
        full_path = os.path.abspath(os.path.join(root, filename))
        if self.output_file and full_path == os.path.abspath(self.output_file):
            logger.debug(f"File {full_path} is excluded since it is the output file for this run")
            return True
        if self.include_prepdir_files:
            return False
        try:
            with open(full_path, "r", encoding="utf-8") as f:
                if PrepdirFileEntry.is_prepdir_outputfile_format(f.read(), file_full_path=full_path):
                    logger.debug(f"Found {full_path} is an output file")
                    return True
        except (IOError, UnicodeDecodeError):
            logger.debug(f"Could not read {full_path} - assuming it is NOT an output file")
            return False
        return False

    def is_excluded_dir(self, dirname: str, root: str) -> bool:
        """
        Check if a directory is excluded based on config.

        Args:
            dirname: Name of the directory to check.
            root: Path to the directory.

        Returns:
            bool: True if the directory is excluded, False otherwise.
        """
        if self.ignore_exclusions:
            return False
        excluded_dir_patterns = self.config.get("EXCLUDE", {}).get("DIRECTORIES", [])
        return is_excluded_dir(dirname, root, self.directory, excluded_dir_patterns)

    def is_excluded_file(self, filename: str, root: str) -> bool:
        """
        Check if a file is excluded based on config.

        Args:
            filename: Name of the file to check.
            root: Directory containing the file.

        Returns:
            bool: True if the file is excluded, False otherwise.
        """
        if self.ignore_exclusions:
            return False
        excluded_dir_patterns = self.config.get("EXCLUDE", {}).get("DIRECTORIES", [])
        excluded_file_patterns = self.config.get("EXCLUDE", {}).get("FILES", [])
        return is_excluded_file(filename, root, self.directory, excluded_dir_patterns, excluded_file_patterns)

    def generate_output(self) -> PrepdirOutputFile:
        """
        Generate the prepdir output file content by traversing the directory or specific files.

        Returns:
            PrepdirOutputFile: Object containing the generated content, files, and metadata.

        Raises:
            ValueError: If no valid files are found.
        """
        output = StringIO()
        uuid_mapping: Dict[str, str] = {}
        placeholder_counter = 1
        timestamp_to_use = datetime.now().isoformat()
        metadata = {
            "version": __version__,
            "date": timestamp_to_use,
            "base_directory": self.directory,
            "creator": f"prepdir version {__version__} (pip install prepdir)",
        }

        with redirect_stdout(output):
            files_found = False
            print(f"File listing generated {timestamp_to_use} by prepdir version {__version__} (pip install prepdir)")
            print(f"Base directory is '{self.directory}'")
            if self.scrub_hyphenated_uuids:
                if self.use_unique_placeholders:
                    print(
                        "Note: Valid (hyphenated) UUIDs in file contents will be scrubbed and replaced with unique placeholders (e.g., PREPDIR_UUID_PLACEHOLDER_n)."
                    )
                else:
                    print(
                        f"Note: Valid (hyphenated) UUIDs in file contents will be scrubbed and replaced with '{self.replacement_uuid}'."
                    )
            if self.scrub_hyphenless_uuids:
                if self.use_unique_placeholders:
                    print(
                        "Note: Valid hyphen-less UUIDs in file contents will be scrubbed and replaced with unique placeholders (e.g., PREPDIR_UUID_PLACEHOLDER_n)."
                    )
                else:
                    print(
                        f"Note: Valid hyphen-less UUIDs in file contents will be scrubbed and replaced with '{self.replacement_uuid.replace('-', '')}'."
                    )

            file_iterator = self._traverse_specific_files() if self.specific_files else self._traverse_directory()
            for file_path in file_iterator:
                files_found = True
                logger.debug(f"adding file {file_path}")
                file_entry, updated_uuid_mapping, placeholder_counter = PrepdirFileEntry.from_file_path(
                    file_path=file_path,
                    base_directory=self.directory,
                    scrub_hyphenated_uuids=self.scrub_hyphenated_uuids,
                    scrub_hyphenless_uuids=self.scrub_hyphenless_uuids,
                    replacement_uuid=self.replacement_uuid,
                    use_unique_placeholders=self.use_unique_placeholders,
                    verbose=self.verbose >= 2,
                    placeholder_counter=placeholder_counter,
                    uuid_mapping=uuid_mapping,
                    stdout=self.stdout,
                    stderr=self.stderr,
                )
                print(file_entry.to_output())
                uuid_mapping.update(updated_uuid_mapping)

            if not files_found:
                if self.specific_files:
                    logger.info("No valid or accessible files found from the provided list.")
                    if not self.quiet:
                        print("No valid or accessible files found from the provided list.", file=self.stdout)
                elif self.extensions:
                    logger.info(f"No files with extension(s) {', '.join(self.extensions)} found.")
                    if not self.quiet:
                        print(f"No files with extension(s) {', '.join(self.extensions)} found.", file=self.stdout)
                else:
                    logger.info("No files found.")
                    if not self.quiet:
                        print("No files found.", file=self.stdout)
                raise ValueError("No files found!")

        content = output.getvalue()
        return PrepdirOutputFile.from_content(
            content=content,
            path_obj=Path(self.output_file) if self.output_file else None,
            uuid_mapping=uuid_mapping,
            metadata=metadata,
            use_unique_placeholders=self.use_unique_placeholders,
        )

    def _traverse_specific_files(self) -> Iterator[Path]:
        """
        Traverse specific files provided in the configuration.

        Yields:
            Path: Paths to valid files that pass exclusion checks.
        """
        for file_path in self.specific_files:
            path = Path(file_path)
            if not path.is_absolute():
                path = Path(self.directory) / path
            path = path.resolve()
            if not path.exists():
                logger.warning(f"File '{file_path}' does not exist")
                if self.verbose >= 1 and not self.quiet:
                    print(f"Warning: File '{file_path}' does not exist", file=self.stdout)
                continue
            if not path.is_file():
                logger.warning(f"'{file_path}' is not a file")
                if self.verbose >= 1 and not self.quiet:
                    print(f"Warning: '{file_path}' is not a file", file=self.stdout)
                continue
            if not self.ignore_exclusions:
                if self.is_excluded_dir(path.parent.name, str(path.parent)):
                    logger.info(f"Skipping file '{file_path}' (parent directory excluded)")
                    if self.verbose >= 1 and not self.quiet:
                        print(f"Skipping file '{file_path}' (parent directory excluded)", file=self.stdout)
                    continue
                if self.is_excluded_file(path.name, str(path.parent)):
                    logger.info(f"Skipping file '{file_path}' (excluded in config)")
                    if self.verbose >= 1 and not self.quiet:
                        print(f"Skipping file '{file_path}' (excluded in config)", file=self.stdout)
                    continue
            if self.is_excluded_output_file(path.name, str(path.parent)):
                logger.info(f"Skipping file: {file_path} (excluded prepdir output file)")
                if self.verbose >= 1 and not self.quiet:
                    print(f"Skipping file: {file_path} (excluded prepdir output file)", file=self.stdout)
                continue
            yield path

    def _traverse_directory(self) -> Iterator[Path]:
        """
        Traverse the directory and yield paths to valid files.

        Yields:
            Path: Paths to valid files that pass exclusion and extension checks.
        """
        logger.debug(f"traversing {self.directory}")
        for root, dirnames, filenames in sorted(os.walk(self.directory)):
            dirnames[:] = [d for d in dirnames if not self.is_excluded_dir(d, root)]
            for filename in sorted(filenames):
                if self.extensions and not any(filename.endswith(f".{ext}") for ext in self.extensions):
                    logger.info(f"Skipping file: {filename} (extension not in {self.extensions})")
                    if self.verbose >= 1 and not self.quiet:
                        print(f"Skipping file: {filename} (extension not in {self.extensions})", file=self.stdout)
                    continue
                if self.is_excluded_output_file(filename, root):
                    logger.info(f"Skipping file: {filename} (excluded output file)")
                    if self.verbose >= 1 and not self.quiet:
                        print(f"Skipping file: {filename} (excluded output file)", file=self.stdout)
                    continue
                if self.is_excluded_file(filename, root):
                    logger.info(f"Skipping file: {filename} (excluded in config)")
                    if self.verbose >= 1 and not self.quiet:
                        print(f"Skipping file: {filename} (excluded in config)", file=self.stdout)
                    continue
                yield Path(root) / filename

    def save_output(self, output: PrepdirOutputFile, path: Optional[str] = None) -> None:
        """
        Save the prepdir output to a file.

        Args:
            output: PrepdirOutputFile object to save.
            path: Optional path to save the file (overrides self.output_file).

        Raises:
            ValueError: If no output path is specified or saving fails.
        """
        output.save(path)

    def validate_output(
        self,
        content: Optional[str] = None,
        file_path: Optional[str] = None,
        metadata: Optional[Dict[str, str]] = None,
        highest_base_directory: Optional[str] = None,
        validate_files_exist: bool = False,
    ) -> PrepdirOutputFile:
        """
        Validate a prepdir output file or content.

        Args:
            content: Raw content to validate.
            file_path: Path to the output file to validate.
            metadata: Optional metadata to include in the output.
            highest_base_directory: Directory to check file paths against.
            validate_files_exist: If True, check if files exist in the filesystem.

        Returns:
            PrepdirOutputFile: Validated output object.

        Raises:
            ValueError: If content or file_path is invalid or paths are outside the base directory.
        """
        if content is not None and file_path is not None:
            raise ValueError("Cannot provide both content and file_path")
        if content is None and file_path is None:
            raise ValueError("Must provide either content or file_path")
        default_metadata = {
            "base_directory": self.directory,
            "version": __version__,
            "date": datetime.now().isoformat(),
            "creator": f"prepdir version {__version__}",
        }
        if metadata:
            default_metadata.update(metadata)
        highest_base = Path(highest_base_directory or self.directory).resolve()
        try:
            if file_path:
                output = PrepdirOutputFile.from_file(
                    path=Path(file_path),
                    metadata=default_metadata,
                    use_unique_placeholders=self.use_unique_placeholders,
                    stderr=self.stderr,
                )
            else:
                output = PrepdirOutputFile.from_content(
                    content=content,
                    path_obj=None,
                    metadata=default_metadata,
                    use_unique_placeholders=self.use_unique_placeholders,
                )
            base_dir = Path(output.metadata["base_directory"]).resolve()
            try:
                base_dir.relative_to(highest_base)
            except ValueError:
                raise ValueError(f"Base directory '{base_dir}' is outside highest base directory '{highest_base}'")
            for entry in output.files.values():
                abs_path = entry.absolute_path.resolve()
                try:
                    abs_path.relative_to(highest_base)
                except ValueError:
                    raise ValueError(f"File path '{abs_path}' is outside highest base directory '{highest_base}'")
                if validate_files_exist and not abs_path.exists():
                    logger.warning(f"File {abs_path} does not exist in filesystem")
                    if self.verbose >= 1 and not self.quiet:
                        print(f"Warning: File {abs_path} does not exist in filesystem", file=self.stdout)
            return output
        except ValueError as e:
            raise ValueError(f"Invalid prepdir output: {str(e)}") from e

    @staticmethod
    def init_config(config_path: str = ".prepdir/config.yaml", force: bool = False, stdout=sys.stdout, stderr=sys.stderr) -> None:
        """
        Initialize a local config.yaml with the package's default config.

        Args:
            config_path: Path to save the config file.
            force: If True, overwrite existing config file.
            stdout: Stream for user-facing output.
            stderr: Stream for error messages.

        Raises:
            SystemExit: If initialization fails or config file already exists without force=True.
        """
        init_config("prepdir", config_path, force, stdout, stderr)